Dec 27, 18:30
Saal 1

Bug class
genocide

Applying
science to
eliminate 100%
of buffer
overflows
--------------
Andreas Bogk

Track:
Security &
Safety

Violation of
memory safety
is still a
major source
of vulnerabili
ties in
everyday
systems. This
talk presents
the state of
the art in
compiler instr
umentation to
completely
eliminate such
vulnerabilitie
s in C/C++
software.
<p>The hacker
community has
a lot of words
for situations
in which
access to the
wrong part of
memory leads
to an
exploitable
vulnerability:
buffer
overflow,
integer
overflows,
stack
smashing, heap
overflow, use-
after-free,
double free
and so on.
Different
words are used
because the
techniques to
trigger the
faulty memory
access and to
subsequently
use that to
gain code
execution
vary, but they
all share a
common root
cause:
violation of
spatial and
temporal
memory
safety.</p>
<p>If one
looks at the
C/C++
standard, the
situations
that tend to
be exploitable
are
"unspecified".
Usually,
compiler
writers take
that as an
excuse to cut
corners, to
gain that
extra bit of
performance in
the
benchmarks.
Because, you
know, who
cares you're
exploitable
when you make
a mistake,
look how fast
it is!</p>
<p>However,
the standards
also allow the
compiler to
introduce
safety checks,
to see whether
access to a
pointer
actually
touches the
inside of an
allocated
object instead
of the outside
(spatial
memory
safety), and
to make sure
that the
pointer being
accessed
actually
points to an
object that
has been
allocated, but
not yet been
freed again
(temporal
memory
safety). Such
compilers do
exist, in the
form of LLVM
with
specialized
optimizer
passes that
introduce
runtime safety
checks.</p>
<p>This talk
will look into
the details of
the implementa
tion, the
performance
impact,
practical
handling, and
of course,
whether it
really
delivers the
promised 100%
protection
against buffer
overflows.</p>